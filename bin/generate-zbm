#!/usr/bin/env perl

use strict;
use warnings;

our $VERSION = '1.4';

use Getopt::Long qw(:config no_ignore_case auto_version);
use Pod::Usage qw(pod2usage);
use File::Basename;
use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::stat;
use File::Path qw(make_path remove_tree);
use File::Glob qw(:globally :nocase);
use Sort::Versions;

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Purity   = 1;

use Config::IniFiles;
use Sort::Versions;
use YAML::PP;
use boolean;

use Storable qw( dclone );

sub versionedKernel;
sub latestKernel;
sub createInitramfs;
sub unifiedEFI;
sub execute;
sub safeCopy;
sub nonempty;
sub cleanupMount;
sub enabled;
sub maxRevision;
sub groupKernels;
sub pruneVersions;
sub purgeFiles;
sub convertConfig;
sub convertImageConfig;

BEGIN {
  $SIG{INT}  = \&cleanupMount;
  $SIG{TERM} = \&cleanupMount;
}

my ( %runConf, %config, %ini_config, %components );

my $configfile;

$runConf{bootdir}   = "/boot";
$runConf{confd}     = "/etc/zfsbootmenu/dracut.conf.d";
$runConf{exit_code} = 0;

GetOptions(
  "version|v=s" => \$runConf{version},
  "kernel|k=s"  => \$runConf{kernel},
  "kver|K=s"    => \$runConf{kernel_version},
  "prefix|p=s"  => \$runConf{kernel_prefix},
  "bootdir|b=s" => \$runConf{bootdir},
  "confd|C=s"   => \$runConf{confd},
  "cmdline|l=s" => \$runConf{cmdline},
  "config|c=s"  => \$configfile,
  "help|h"      => sub {
    my $bin  = basename($0);
    my $help = << "EOF";
Usage: $bin [options]
  -v|--version    Manually set the version
  -k|--kernel     Manually set the path to the kernel
  -K|--kver       Manually set the kernel version
  -p|--prefix     Manually set the output kernel prefix
  -b|--bootdir    Manually set the location to search for kernel files
  -C|--confd      Manually set the Dracut configuration directory
  -c|--config     Manually set the configuration file
  -l|--cmdline    Manually set the kernel command line
EOF
    print $help;
    exit;
  },
);

unless ( nonempty $configfile ) {
  my $inifile = "/etc/zfsbootmenu/config.ini";
  $configfile = "/etc/zfsbootmenu/config.yaml";

  # Convert a default INI to YAML if no YAML config exists
  if ( -f $inifile and !-f $configfile ) {
    print "Converting $inifile to $configfile\n";
    convertConfig $inifile, $configfile;
    print "Please verify the converted file and re-run $0\n";
    exit;
  }
}

if ( -r $configfile ) {
  my $yaml = YAML::PP->new( boolean => 'boolean' )->load_file($configfile);
  %config = %$yaml;
} else {
  printf "Configuration %s does not exist or is unreadable\n", $configfile;
  exit 1;
}

unless ( $config{Global}{ManageImages} ) {
  print "ManageImages not enabled, no action taken\n";
  exit;
}

# Override the location of our specific dracut.conf.d directory
if ( nonempty $config{Global}{DracutConfDir} ) {
  $runConf{confd} = $config{Global}{DracutConfDir};
}

# Ensure our bootloader partition is mounted
$runConf{umount_on_exit} = 0;
if ( nonempty $config{Global}{BootMountPoint} ) {
  my $mounted = 0;

  my $cmd    = "mountpoint $config{Global}{BootMountPoint}";
  my @output = execute($cmd);
  my $status = pop(@output);
  unless ( $status eq 0 ) {
    print "Mounting $config{Global}{BootMountPoint}\n";
    $cmd = "mount $config{Global}{BootMountPoint}";
    my @output = execute($cmd);
    my $status = pop(@output);
    if ( $status eq 0 ) {
      $runConf{umount_on_exit} = 1;
    } else {
      foreach my $line (@output) {
        print $line;
      }
      printf "Unable to mount %s\n", $config{Global}{BootMountPoint};
      $runConf{exit_code} = $status;
      exit;
    }
  }
}

# Create a temp directory
# It is automatically purged on program exit
my $dir     = File::Temp->newdir();
my $tempdir = $dir->dirname;

# Config file may provide some default values for command-line args
if ( nonempty $config{Kernel}{Path} and !nonempty $runConf{kernel} ) {
  $runConf{kernel} = $config{Kernel}{Path};
}

if ( nonempty $config{Kernel}{Prefix} and !nonempty $runConf{kernel_prefix} ) {
  $runConf{kernel_prefix} = $config{Kernel}{Prefix};
}

if ( nonempty $config{Kernel}{Version} and !nonempty $runConf{kernel_version} ) {
  $runConf{kernel_version} = $config{Kernel}{Version};
  $runConf{kernel_version} =~ s/%current\b/%{current}/i;
}

if ( nonempty $config{Global}{Version} and !nonempty $runConf{version} ) {
  $runConf{version} = $config{Global}{Version};
}

if ( nonempty $config{Kernel}{CommandLine} and !nonempty $runConf{cmdline} ) {
  $runConf{cmdline} = $config{Kernel}{CommandLine};
}

if ( nonempty $runConf{version} ) {
  $runConf{version} =~ s/%current\b/%current/i;
  $runConf{version} =~ s/%\{current\}/$VERSION/i;
} else {
  $runConf{version} = $VERSION;
}

# Map "%current" kernel version to output of `uname r`
if ( nonempty $runConf{kernel_version} and $runConf{kernel_version} =~ /%\{current\}/i ) {
  my @uname  = execute(qw(uname -r));
  my $status = pop(@uname);
  unless ( $status eq 0 and scalar @uname ) {
    print "Cannot determine current kernel version\n";
    $runConf{exit_code} = $status;
    exit;
  }
  chomp @uname;
  $runConf{kernel_version} =~ s/%\{current\}/$uname[0]/i;
}

if ( nonempty $runConf{kernel} ) {
  # Make sure the provided kernel file exists
  unless ( -f $runConf{kernel} ) {
    printf "The provided kernel %s was not found, unable to continue\n", $runConf{kernel};
    exit;
  }
} else {

  # Try to determine a kernel file when one was not provided
  if ( nonempty $runConf{kernel_version} ) {
    $runConf{kernel} = versionedKernel $runConf{kernel_version};
  } else {
    $runConf{kernel} = latestKernel;
  }

  # Make sure a kernel was found
  unless ( nonempty $runConf{kernel} ) {
    print "Unable to choose a kernel file, cannot continue\n";
    exit;
  }
}

# Try to determine kernel_prefix or kernel_version if necessary
unless ( nonempty $runConf{kernel_prefix} and nonempty $runConf{kernel_version} ) {
  basename( $runConf{kernel} ) =~ m/([^-\s]+)(-(\S+))?/;
  unless ( nonempty $runConf{kernel_prefix} ) {
    unless ( defined $1 ) {
      printf "Unable to determine kernel prefix from %s\n", $runConf{kernel};
      exit;
    }
    $runConf{kernel_prefix} = $1;
  }
  unless ( nonempty $runConf{kernel_version} ) {
    unless ( defined $3 ) {
      printf "Unable to detrmine kernel version from %s\n", $runConf{kernel};
      exit;
    }
    $runConf{kernel_version} = $3;
  }
}

printf "Creating ZFS Boot Menu %s from kernel %s\n", $runConf{version}, $runConf{kernel};

# Create a unified kernel/initramfs/command line EFI file
if ( enabled $config{EFI} ) {
  my $unified_efi = unifiedEFI( $tempdir, $runConf{kernel}, $runConf{kernel_version} );

  my $efi_target;

  my $efi_prefix   = sprintf( "%s/%s", $config{EFI}{ImageDir}, $runConf{kernel_prefix} );
  my $efi_versions = int $config{EFI}{Versions};

  if ( $efi_versions > 0 ) {
    # Find UEFI bundles and group by apparent version
    my @efi        = glob sprintf( "%s-*.EFI", $efi_prefix );
    my $efi_groups = groupKernels( \@efi, $efi_prefix, ".EFI" );

    # Determine the revision to use for this image
    my $revision = maxRevision( $efi_groups->{ $runConf{version} }, ".EFI" ) + 1;
    $efi_target = sprintf( "%s-%s_%s.EFI", $efi_prefix, $runConf{version}, $revision );

    # Prune the old versions
    pruneVersions $efi_groups, $runConf{version}, $efi_versions;
  } else {
    $efi_target = sprintf( "%s.EFI", $efi_prefix );
    my $efi_backup = sprintf( "%s-backup.EFI", $efi_prefix );

    if ( -f $efi_target and safeCopy( $efi_target, $efi_backup ) ) {
      printf "Created backup %s -> %s\n", $efi_target, $efi_backup;
    }
  }

  make_path $config{EFI}{ImageDir};
  if ( safeCopy( $unified_efi, $efi_target, 0 ) ) {
    printf "Created new UEFI image %s\n", $efi_target;
  }
}

# Create a separate kernel / initramfs. Used by syslinux/extlinux/grub.
if ( enabled $config{Components} ) {
  my $initramfs = createInitramfs( $tempdir, $runConf{kernel_version} );

  my ( $kernel_target, $initramfs_target );

  my $component_prefix   = sprintf( "%s/%s", $config{Components}{ImageDir}, $runConf{kernel_prefix} );
  my $component_versions = int $config{Components}{Versions};

  if ( $component_versions > 0 ) {

    # Find ZBM kernels and group by apparent version
    my @kernels     = glob( sprintf( "%s-*", $component_prefix ) );
    my $kern_groups = groupKernels( \@kernels, $component_prefix );

    my $revision = maxRevision( $kern_groups->{ $runConf{version} } ) + 1;
    $kernel_target = sprintf( "%s-%s_%s", $component_prefix, $runConf{version}, $revision );
    $initramfs_target =
      sprintf( "%s/initramfs-%s_%s.img", $config{Components}{ImageDir}, $runConf{version}, $revision );

    # Prune old versions
    pruneVersions $kern_groups, $runConf{version}, $component_versions;

    # Map kernel to initramfs and prune
    keys %$kern_groups;
    while ( my ( $kver, $image ) = each %$kern_groups ) {
      foreach (@$image) {
        s/\Q$component_prefix\E/$config{Components}{ImageDir}\/initramfs/;
        s/$/.img/;
      }
    }
    pruneVersions $kern_groups, $runConf{version}, $component_versions;
  } else {
    $kernel_target    = sprintf( "%s-bootmenu",               $component_prefix );
    $initramfs_target = sprintf( "%s/initramfs-bootmenu.img", $config{Components}{ImageDir} );

    my $kernel_backup    = sprintf( "%s-backup",                        $kernel_target );
    my $initramfs_backup = sprintf( "%s/initramfs-bootmenu-backup.img", $config{Components}{ImageDir} );

    if ( -f $kernel_target and safeCopy( $kernel_target, $kernel_backup ) ) {
      printf "Created backup %s -> %s\n", $kernel_target, $kernel_backup;
    }

    if ( -f $initramfs_target and safeCopy( $initramfs_target, $initramfs_backup ) ) {
      printf "Created backup %s -> %s\n", $initramfs_target, $initramfs_backup;
    }
  }

  make_path $config{Components}{ImageDir};

  if ( safeCopy( $runConf{kernel}, $kernel_target, 0 ) ) {
    printf "Created kernel image %s\n", $kernel_target;
  }

  if ( safeCopy( $initramfs, $initramfs_target, 0 ) ) {
    printf "Created initramfs image %s\n", $initramfs_target;
  }
}

# Generate syslinux.cfg, requires components to be built
if ( enabled $config{Components}{syslinux} ) {
  my $glob    = sprintf( "%s/%s-*", $config{Components}{ImageDir}, $runConf{kernel_prefix} );
  my @listing = sort versioncmp glob($glob);

  # Filter EFI files, in case they're in the same directory
  my @components;
  foreach my $entry (@listing) {
    if ( $entry =~ /EFI$/i ) {
      next;
    }
    push( @components, $entry );
  }

  $runConf{syslinux_temp} = join( '/', $tempdir, 'syslinux.conf' );
  open CFG, '>', $runConf{syslinux_temp};

  my $header = <<'EOF';
UI menu.c32
PROMPT 0

MENU TITLE Boot Menu
TIMEOUT 50
EOF

  print CFG $header;

  my $add_default = 1;
  while (@components) {
    my $entry = pop(@components);

    my $directory = dirname($entry);

    # Strip the mountpoint prefix out to generate a correct path based on /
    $directory =~ s/\Q$config{Global}{BootMountPoint}//;

    my $kernel = basename($entry);
    my ( undef, $version ) = split( '-', $kernel );
    my $label      = "ZFSBootMenu-$version";
    my $menu_label = "ZFS Boot Menu v$version";

    if ($add_default) {
      print CFG "DEFAULT $label\n\n";
      $add_default--;
    }

    print CFG "LABEL $label\n";
    print CFG "MENU LABEL $menu_label\n";
    print CFG "KERNEL $directory/$kernel\n";
    print CFG "INITRD $directory/initramfs-$version.img\n";
    print CFG "APPEND $runConf{cmdline}\n";
    print CFG "\n";

  }
  close CFG;

  make_path dirname( $config{Components}{syslinux}{Config} );
  safeCopy( $runConf{syslinux_temp}, $config{syslinux}{Config} );
}

END {
  cleanupMount;
}

# Finds specifically versioned kernel in /boot
sub versionedKernel {
  my ( $kver, ) = @_;

  foreach my $prefix (qw(vmlinuz linux vmlinux kernel)) {
    my $kernel = join( '/', ( $runConf{bootdir}, join( '-', ( $prefix, $kver ) ) ) );
    if ( -f $kernel ) {
      return $kernel;
    }
  }

  return;
}

# Finds the latest kernel in /boot
sub latestKernel {
  my @prefixes = ( "vmlinux*", "vmlinuz*", "linux*", "kernel*" );
  for my $prefix (@prefixes) {
    my $glob    = join( '/', ( $runConf{bootdir}, $prefix ) );
    my @kernels = glob($glob);
    next if !@kernels;
    for ( sort { versioncmp( $b, $a ) } @kernels ) {
      return $_;
    }
  }

  return;
}

# Returns the path to an initramfs, or dies with an error
sub createInitramfs {
  my ( $temp, $kver ) = @_;

  my $output_file = join( '/', $temp, "zfsbootmenu" );
  my @cmd         = ( qw(dracut -q -f --confdir), $runConf{confd}, $output_file, qw(--kver), $kver, );
  my @output      = execute(@cmd);
  my $status      = pop(@output);
  if ( $status eq 0 ) {
    return $output_file;
  } else {
    foreach my $line (@output) {
      print $line;
    }
    print "Failed to create $output_file\n";
    $runConf{exit_code} = $status;
    exit;
  }
}

sub unifiedEFI {
  my ( $temp, $kernfile, $kver ) = @_;

  my $output_file = join( '/', $temp, "zfsbootmenu.efi" );
  my $efi_stub    = $config{EFI}{Stub} || "/usr/lib/gummiboot/linuxx64.efi.stub";

  unless ( -e $efi_stub ) {
    die "Missing EFI stub: $efi_stub";
  }

  my @cmd = (
    qw(dracut -q -f --uefi --confdir), $runConf{confd},
    qq(--uefi-stub), $efi_stub, qq(--kernel-image), $kernfile, );

  if ( nonempty $runConf{cmdline} ) {
    push @cmd, qq(--kernel-cmdline=\"$runConf{cmdline}\");
  }

  push @cmd, ( qq(--kver), $kver, $output_file, );

  my @output = execute(@cmd);
  my $status = pop(@output);
  if ( $status eq 0 ) {
    return $output_file;
  } else {
    foreach my $line (@output) {
      print $line;
    }
    print "Failed to create $output_file\n";
    $runConf{exit_code} = $status;
    exit;
  }
}

sub execute {
  ( @_ = qx{@_ 2>&1}, $? >> 8 );
}

sub safeCopy {
  my ( $source, $dest, $savetime ) = @_;

  my $preserve = ( defined $savetime ) ? boolean($savetime) : true;

  unless ( copy( $source, $dest ) ) {
    printf "Unable to copy %s to %s: %s\n", $source, $dest, $!;
    return 0;
  }

  if ($preserve) {

    # Copy the access and mod times if possible
    my $sb = stat $source;
    utime( $sb->atime, $sb->mtime, $dest );
  }

  return 1;
}

sub nonempty {
  my $item = shift;
  return ( defined $item and length $item );
}

sub enabled {
  my $section = shift;
  return ( defined $section->{Enabled} and $section->{Enabled} );
}

sub cleanupMount {
  if ( $runConf{umount_on_exit} ) {
    print "Unmounting $config{Global}{BootMountPoint}\n";
    my $cmd = "umount $config{Global}{BootMountPoint}";
    execute($cmd);
  }
  exit $runConf{exit_code};
}

sub maxRevision {
  my ( $files, $suffix ) = @_;
  my $revision = 0;

  $suffix = "" unless ( defined $suffix );

  foreach my $file (@$files) {
    if ( $file =~ /_(\d+)\Q$suffix\E$/ ) {
      $revision = $1 if ( $1 > $revision );
    }
  }

  return $revision;
}

sub groupKernels {
  my ( $kernels, $prefix, $suffix ) = @_;
  my %groups;

  $suffix = "" unless ( defined $suffix );

  foreach my $kernel (@$kernels) {
    next unless ( $kernel =~ /^\Q$prefix\E-(.+)_\d+\Q$suffix\E$/ );
    push @{ $groups{$1} }, $kernel;
  }

  return \%groups;
}

sub pruneVersions {
  my ( $versions, $current, $keep ) = @_;
  my $old_version;

  $keep = 0 unless ( defined $keep and $keep gt 0 );

  # Keep revisions current version
  purgeFiles $versions->{$current}, $keep;

  # Sort the versions and remove the current
  my @old_versions = sort versioncmp keys %$versions;

  my $index = 0;
  foreach my $key (@old_versions) {
    if ( $key eq $current ) {
      splice @old_versions, $index, 1;
    } else {
      $index++;
    }
  }

  # Purge all of the too-old revisions
  while ( scalar @old_versions > $keep ) {
    $old_version = shift @old_versions;
    purgeFiles $versions->{$old_version};
  }

  # Purge all but the remaining revision of the leftover versions
  foreach $old_version (@old_versions) {
    purgeFiles $versions->{$old_version}, 1;
  }
}

sub purgeFiles {
  my ( $files, $keep ) = @_;

  return unless ( defined $files );

  $keep = 0 unless ( defined $keep and $keep gt 0 );

  if ( $keep gt 0 ) {
    my @sorted_files = sort versioncmp @$files;
    while ( scalar @sorted_files > $keep ) {
      my $file = shift @sorted_files;
      if ( -f $file ) {
        print "Removing file $file\n";
        unlink $file;
      }
    }
  } else {
    foreach my $file (@$files) {
      if ( -f $file ) {
        print "Removing file $file\n";
        unlink $file;
      }
    }
  }
}

sub convertConfig {
  my ( $inifile, $configfile ) = @_;

  tie %ini_config, 'Config::IniFiles', ( -file => $inifile );

  my $yaml = YAML::PP->new( boolean => 'boolean' );

  # Force boolean
  $ini_config{Global}{ManageImages} = boolean( $ini_config{Global}{ManageImages} );

  # Convert the component and EFI image sections to the new format
  convertImageConfig $ini_config{Components};
  convertImageConfig $ini_config{EFI};

  # Move syslinux to be a sub section of Components
  $ini_config{Components}{syslinux} = dclone( $ini_config{syslinux} );
  $ini_config{Components}{syslinux}{Enabled} = boolean( $ini_config{Components}{syslinux}{CreateConfig} );
  delete $ini_config{Components}{syslinux}{CreateConfig};
  delete $ini_config{syslinux};

  $yaml->dump_file( $configfile, \%ini_config );
}

sub convertImageConfig {
  my $section = shift;

  $section->{Enabled} = boolean( $section->{Copies} > 0 );
  $section->{Enabled} = boolean( $section->{Copies} > 0 );

  if ( $section->{Versioned} ) {
    if ( $section->{Copies} > 1 ) {
      $section->{Versions} = int $section->{Copies};
    } else {
      $section->{Versions} = true;
    }
  } else {
    $section->{Versions} = false;
  }

  delete $section->{Versioned};
  delete $section->{Copies};
}
